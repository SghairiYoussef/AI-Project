package code.model;

import java.nio.file.*;
import java.io.IOException;
import java.util.*;

/**
 * .world parser supporting:
 * GRID W H
 * STORE x y
 * DEST x y
 * AGENT id x y
 * EDGE x1 y1 x2 y2 cost
 * UNDIRECTED_EDGE x1 y1 x2 y2 cost
 * BLOCK x1 y1 x2 y2
 * TUNNEL x1 y1 x2 y2
 *
 * Comments start with #
 */
public class WorldParser {
    public static Grid parse(String path) throws IOException {
        List<String> lines = Files.readAllLines(Path.of(path));
        Grid grid = null;
        for(String raw : lines){
            String line = raw.trim();
            if(line.isEmpty() || line.startsWith("#")) continue;
            String[] tok = line.split("\\s+");
            String cmd = tok[0].toUpperCase();
            switch(cmd){
                case "GRID":
                    grid = new Grid(Integer.parseInt(tok[1]), Integer.parseInt(tok[2]));
                    break;
                case "STORE":
                    grid.stores.add(new Position(Integer.parseInt(tok[1]), Integer.parseInt(tok[2])));
                    break;
                case "DEST":
                    grid.destinations.add(new Position(Integer.parseInt(tok[1]), Integer.parseInt(tok[2])));
                    break;
                case "AGENT":
                    grid.agents.add(new Agent(tok[1], new Position(Integer.parseInt(tok[2]), Integer.parseInt(tok[3]))));
                    break;
                case "EDGE":
                    Position a = new Position(Integer.parseInt(tok[1]), Integer.parseInt(tok[2]));
                    Position b = new Position(Integer.parseInt(tok[3]), Integer.parseInt(tok[4]));
                    int cost = Integer.parseInt(tok[5]);
                    grid.setEdge(a,b,cost);
                    break;
                case "UNDIRECTED_EDGE":
                    Position a1 = new Position(Integer.parseInt(tok[1]), Integer.parseInt(tok[2]));
                    Position b1 = new Position(Integer.parseInt(tok[3]), Integer.parseInt(tok[4]));
                    int cost1 = Integer.parseInt(tok[5]);
                    grid.setEdge(a1,b1,cost1);
                    grid.setEdge(b1,a1,cost1);
                    break;
                case "BLOCK":
                    Position p1 = new Position(Integer.parseInt(tok[1]), Integer.parseInt(tok[2]));
                    Position p2 = new Position(Integer.parseInt(tok[3]), Integer.parseInt(tok[4]));
                    grid.setEdge(p1,p2,0);
                    grid.setEdge(p2,p1,0);
                    break;
                case "TUNNEL":
                    Position ta = new Position(Integer.parseInt(tok[1]), Integer.parseInt(tok[2]));
                    Position tb = new Position(Integer.parseInt(tok[3]), Integer.parseInt(tok[4]));
                    grid.addTunnel(ta,tb);
                    break;
                default:
                    System.err.println("Unknown directive: " + cmd);
            }
        }
        if(grid == null) throw new IllegalArgumentException("World file must start with GRID W H");
        return grid;
    }
    
    /**
     * Parse a grid string generated by GridGenerator.genGrid()
     * Format: m;n;P;S;StoreCoords;DestCoords;TunnelCoords;Obstacles;Traffic
     */
    public static Grid parseGridString(String gridString) {
        String[] parts = gridString.split(";");
        
        int m = Integer.parseInt(parts[0]);
        int n = Integer.parseInt(parts[1]);
        // int numProducts = Integer.parseInt(parts[2]); // not used for grid creation
        // int numStores = Integer.parseInt(parts[3]); // not used for grid creation
        
        Grid grid = new Grid(m, n);
        
        // Parse stores (part 4)
        if (parts.length > 4 && !parts[4].isEmpty()) {
            String[] storeCoords = parts[4].split(",");
            for (int i = 0; i + 1 < storeCoords.length; i += 2) {
                int x = Integer.parseInt(storeCoords[i]);
                int y = Integer.parseInt(storeCoords[i + 1]);
                Position store = new Position(x, y);
                grid.stores.add(store);
            }
        }
        
        // Parse destinations (part 5)
        if (parts.length > 5 && !parts[5].isEmpty()) {
            String[] destCoords = parts[5].split(",");
            for (int i = 0; i + 1 < destCoords.length; i += 2) {
                int x = Integer.parseInt(destCoords[i]);
                int y = Integer.parseInt(destCoords[i + 1]);
                grid.destinations.add(new Position(x, y));
            }
        }
        
        // Parse tunnels (part 6)
        if (parts.length > 6 && !parts[6].isEmpty()) {
            String[] tunnelCoords = parts[6].split(",");
            for (int i = 0; i + 3 < tunnelCoords.length; i += 4) {
                int x1 = Integer.parseInt(tunnelCoords[i]);
                int y1 = Integer.parseInt(tunnelCoords[i + 1]);
                int x2 = Integer.parseInt(tunnelCoords[i + 2]);
                int y2 = Integer.parseInt(tunnelCoords[i + 3]);
                grid.addTunnel(new Position(x1, y1), new Position(x2, y2));
            }
        }
        
        // Create full grid connectivity with random traffic
        java.util.Random rand = new java.util.Random();
        for (int x = 0; x < m; x++) {
            for (int y = 0; y < n; y++) {
                Position p = new Position(x, y);
                
                // Right edge
                if (x < m - 1) {
                    int cost = rand.nextInt(4) + 1;
                    grid.setEdge(p, new Position(x + 1, y), cost);
                    grid.setEdge(new Position(x + 1, y), p, cost);
                }
                
                // Down edge
                if (y < n - 1) {
                    int cost = rand.nextInt(4) + 1;
                    grid.setEdge(p, new Position(x, y + 1), cost);
                    grid.setEdge(new Position(x, y + 1), p, cost);
                }
            }
        }
        
        // Parse obstacles if present (part 7)
        if (parts.length > 7 && !parts[7].isEmpty()) {
            String[] obstacles = parts[7].split(",");
            for (int i = 0; i + 3 < obstacles.length; i += 4) {
                int x1 = Integer.parseInt(obstacles[i]);
                int y1 = Integer.parseInt(obstacles[i + 1]);
                int x2 = Integer.parseInt(obstacles[i + 2]);
                int y2 = Integer.parseInt(obstacles[i + 3]);
                Position p1 = new Position(x1, y1);
                Position p2 = new Position(x2, y2);
                grid.setEdge(p1, p2, 0); // Blocked
                grid.setEdge(p2, p1, 0);
            }
        }
        
        // Add agents at stores - one truck per store
        for (int i = 0; i < grid.stores.size(); i++) {
            Position storePos = grid.stores.get(i);
            grid.agents.add(new Agent("Agent" + (i + 1), new Position(storePos.x, storePos.y)));
        }
        
        return grid;
    }
}
